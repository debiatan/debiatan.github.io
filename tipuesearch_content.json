{"pages":[{"text":"Placeholder text post += 1 import itertools def rule_I ( s ): if s [ - 1 ] != 'I' : return () return [ s + 'U' ] def rule_II ( s ): if s [ 0 ] != 'M' or len ( s ) <= 1 : return () return [ s [ 0 ] + s [ 1 :] * 2 ] def substitute_each_occurrence ( s , ss , new_ss ): \"\"\" s: string, ss: substring, new_ss: new substring \"\"\" res = [] n_ss = len ( ss ) i = 0 while i <= len ( s ) - n_ss : if s [ i : i + n_ss ] == ss : res . append ( s [: i ] + new_ss + s [ i + n_ss :]) i += 1 return res def rule_III ( s ): return substitute_each_occurrence ( s , 'III' , 'U' ) def rule_IV ( s ): return substitute_each_occurrence ( s , 'UU' , '' ) def derive ( axiom , target_theorem , rules ): derivation = { axiom :[]} # Shortest chain of rules needed to reach a theorem theorems = set ([ axiom ]) while target_theorem not in theorems : # Breadth-first search for theorem , rule in itertools . product ( set ( theorems ), rules ): for new_theorem in rule ( theorem ): if new_theorem not in theorems : theorems . add ( new_theorem ) derivation [ new_theorem ] = derivation [ theorem ] + [ rule ] return [ rule . __name__ for rule in derivation [ target_theorem ]] rule_chain = derive ( axiom = 'MI' , target_theorem = 'MUIIU' , rules = ( rule_I , rule_II , rule_III , rule_IV )) print ( rule_chain ) Placeholder text 2","tags":"Test","loc":"http://blog.debiatan.net/test-post.html","title":"Test post"}]}