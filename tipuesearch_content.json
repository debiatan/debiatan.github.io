{"pages":[{"text":"I've started writing a simple graphical debugger for the limited subset of C++ that Casey Muratori uses in Handmade Hero and I've already made two big mistakes. The first one is thinking that I could write a better GDB frontend than those available today, when the truth of the matter is that GDB does not want graphical frontends . The second one is using libdwarf to parse the DWARF debug information of ELF binaries. What drove me to use libdwarf was Eli Bendersky's third article on debugging and linux (the other two talk about ptrace and implementing breakpoints ) That article advises against trying to parse the DWARF section of an executable manually, arguing that DWARF is a very complex format, requiring the implementation of two \"specialized virtual machines\" to decode location data and line number data. I read that and thought \"sure, let's give libdwarf a try\". While a cursory look at the DWARF spec makes me believe that libdwarf does, in fact, hide some of the complexity of the DWARF format, I've found that its API carries its own set of problems, particularly on the memory management side of things. The main complaint I have is that every time I make a call to libdwarf, it allocates space for the response under an opaque pointer and asks me to remember the type of the request, so that later I can ask the library to free that memory. The natural consequence of such a design is that two thirds of the code that I write to interface with libdwarf end up being spent managing memory outside of my control. This example, extracted from the official documentation, illustrates my point (I've added the last else if branch to avoid leaking memory through the error descriptor): void example1 ( Dwarf_Die somedie ) { Dwarf_Debug dbg = 0 ; Dwarf_Signed atcount ; Dwarf_Attribute * atlist ; Dwarf_Error error = 0 ; Dwarf_Signed i = 0 ; int errv ; errv = dwarf_attrlist ( somedie , & atlist , & atcount , & error ); if ( errv == DW_DLV_OK ) { for ( i = 0 ; i < atcount ; ++ i ) { /* use atlist[i] */ dwarf_dealloc ( dbg , atlist [ i ], DW_DLA_ATTR ); } dwarf_dealloc ( dbg , atlist , DW_DLA_LIST ); } else if ( errv == DW_DLV_ERROR ){ /* use error */ dwarf_dealloc ( dbg , error , DW_DLA_ERROR ); } } This piece of code takes a DWARF Debug Information Entry and asks about its attributes (key-value pairs describing it, such as name, size, ...). If the number of attributes returned by the function is n , then the number of dwarf_dealloc calls needed will be n+1 , one for each of the attributes and another one for the list itself. Also, notice how libdwarf fails to keep track of the types of pointers it allocates, transferring that burden onto the caller. This means that every call to dwarf_dealloc needs to specify one among these identifiers: DW_DLA_STRING , DW_DLA_LOC , DW_DLA_LOCDESC , DW_DLA_ELLIST , DW_DLA_BOUNDS , DW_DLA_BLOCK , DW_DLA_DEBUG , DW_DLA_DIE , DW_DLA_LINE , DW_DLA_ATTR , DW_DLA_TYPE , DW_DLA_SUBSCR , DW_DLA_GLOBAL_CONTEXT , DW_DLA_ERROR , DW_DLA_LIST , DW_DLA_LINEBUF , DW_DLA_ARANGE , DW_DLA_ABBREV , DW_DLA_FRAME_OP , DW_DLA_CIE , DW_DLA_FDE , DW_DLA_LOC_BLOCK , DW_DLA_FRAME_BLOCK , DW_DLA_FUNC_CONTEXT , DW_DLA_TYPENAME_CONTEXT , DW_DLA_VAR_CONTEXT , DW_DLA_WEAK_CONTEXT and DW_DLA_PUBTYPES_CONTEXT . That's a clear violation of the eighth item of Casey Muratori's 2004 Designing and Evaluating Reusable Components API design checklist (which, by the way, deserves a wider audience): Use of the component's resource management (memory, file, string, etc.) is completely optional. In order to sidestep this issue, I've decided to modify libdwarf and make it use my own custom allocator functions, effectively taking control of memory back from the library. The last revision of libdwarf (January, 2016) makes 34 calls to malloc , 10 to calloc , 1 call to realloc and under 100 calls to free . I've gotten rid of the realloc call, which was only there because of some sloppy coding, and I've replaced the rest with calls to functions specified by the user through three extra parameters I've added to dwarf_init . My use case for libdwarf consists on parsing the whole binary in one go, building my own intermediate representation of the debugging information and, once I'm done, discarding all memory allocated through that library. That allows me to make my malloc and calloc functions use a simple stack allocator and to replace free with an empty function. Here's a barebones example of the way I use the tweaked libdwarf: /* Compile with: clang -std=c++11 -Wl,-export-dynamic,-rpath=. libdwarf.so \\ example.cc -o example -lelf */ #include <stdint.h> #include <stdlib.h> #include <string.h> #include <fcntl.h> #include <assert.h> #include \"libdwarf.h\" struct MemoryArena { uint8_t * base ; size_t size ; size_t used ; }; void * push_size ( MemoryArena * arena , size_t size , bool clear = false ){ assert (( arena -> used + size ) <= arena -> size ); void * result = arena -> base + arena -> used ; arena -> used += size ; if ( clear ) memset ( result , 0 , size ); return result ; } static MemoryArena dwarf_arena ; void * stack_malloc ( size_t size ){ return push_size ( & dwarf_arena , size ); } void * stack_calloc ( size_t nmemb , size_t size ){ return push_size ( & dwarf_arena , nmemb * size , true ); } void stack_free ( void * ){} int main ( void ){ // Memory arena initialization int bytes_to_allocate = 1024 * 1024 ; dwarf_arena . base = ( uint8_t * ) malloc ( bytes_to_allocate ); dwarf_arena . size = bytes_to_allocate ; dwarf_arena . used = 0 ; int fd = open ( \"inferior\" , O_RDONLY ); // ELF target Dwarf_Debug dbg ; Dwarf_Error err ; dwarf_init ( fd , DW_DLC_READ , 0 , 0 , & dbg , & err , stack_malloc , stack_calloc , stack_free ); // Call as many dwarf_* functions as necessary to build // my own representation of debug information without // worrying about dwarf_dealloc or dwarf_finish // Recycling of dwarf memory arena for other purposes dwarf_arena . used = 0 ; MemoryArena some_other_arena = dwarf_arena ; dwarf_arena = {}; // Code that does something useful with the debug symbols return 0 ; } If you ever find yourself in a situation similar to mine, you can get the source of the modified libdwarf from this github repository . You will also need to install the libelf-dev package that comes with you Linux distribution. However, I urge you to reconsider using libdwarf . The obtuseness of it's memory allocation scheme is just my main complaint about it, but my dislike for its API does not stop there. Also, remember those two terribly complicated \"specialized virtual machines\" Eli Bendersky mentioned? Turns out that libdwarf only implements one of them. Here's what libdwarf's documentation has to say about the other one: 6.22 Location Expression Evaluation An \"interpreter\" which evaluates a location expression is required in any debugger. There is no interface defined here at this time. One problem with defining an interface is that operations are machine dependent: they depend on the interpretation of register numbers and the methods of getting values from the environment the expression is applied to. It would be desirable to specify an interface.","tags":"tools","loc":"https://blog.debiatan.net/libdwarf_with_custom_memory_allocators.html","title":"Libdwarf with custom memory allocators"},{"text":"GDB is an OK command-line debugger, but its not a solid foundation for graphical debuggers. According to the GDB documentation, the recommended way of interacting with the debugger is through the GDB/MI interface , which offers almost the same functionality as the regular GDB command-line through an alternative text protocol with a well-defined but somewhat obtuse grammar. If all we need is the ability to automate a GDB session, then GDB/MI is probably enough, but if we want our frontend to provide functionality not present in GDB, we may be out of luck. As an example, let's imagine we want to ask GDB about the value associated to a variable. In a regular command-line debugging session, we would issue a print command specifying the name of the variable and the debugger would look for it inside the blocks encompassing our current line to provide an answer. What happens, however, when we try to implement mouseover variable inspection? Suddenly, the current line can't act as an implicit location for our queries and the variable we want to inspect may not be uniquely identified by its name. Take for instance this run-of-the-mill piece of C++ code, representative of my coding style on Friday afternoons: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main ( void ){ float thing = 2.f ; { int thing = 3 ; int lets_break_here = 0 ; { char thing = 'a' ; // thing in a comment #if 0 thing #endif } } for ( int i = 0 ; i < 10 ; ++ i ){ thing = thing * thing ; } return 0 ; } Let's say we decide to stop on line five and inspect the values associated to all available thing s using Emacs' gud-tooltip-mode. The result are wrong most of the time. Maybe KDevelop has other thoughts on the matter... Not really. Qt-creator? This one at least does not fall for the commented thing and even acknowledges the existence of other types of thing s somewhere else in the program. But still, I'm beginning to suspect that GDB frontend programmers don't usually debug the sort of code I tend to work on. The results are the same for Eclipse's CDT standalone debugger and for DDD. I can't say what CLion and Nemiver do, because they refuse to work on my machine. Figuring out the lexical scope of variables in C programs is not that hard. All these frontends fail to implement it properly because GDB makes it hard for them. Sure, they could issue an info scope 7 command and find out the addresses and sizes of all variables relative to the stack base pointer for all scopes encompassing line seven: Scope for 7: Symbol thing is a variable at frame base reg $rbp offset 0+-17, length 1. Symbol thing is a variable at frame base reg $rbp offset 0+-12, length 4. Symbol lets_break_here is a variable at frame base reg $rbp offset 0+-16, length 4. Symbol thing is a variable at frame base reg $rbp offset 0+-8, length 4. Then, they would only need to infer somehow which thing 's which, find its type and format its value accordingly. At this point it may be easier to read the DWARF debug information directly and avoid GDB altogether. Or we could just purchase a Windows license, download Visual Studio Community Whatever, register it and... Oops! I suppose the problem here is that the Visual Studio team cares mostly about C#, and since C# does not allow variables with the same name in nested scopes...","tags":"opinion","loc":"https://blog.debiatan.net/a_limitation_of_gdb_frontends.html","title":"A limitation of GDB frontends"},{"text":"I was born in 1981, but I still got late to the PC party. My first computer was a Pentium 100, 8 MB RAM, 850 MB HDD, 14-inch CRT beast. My parents bought it for my brother and me on December 1995. Some weeks before lugging it home, I was already making preparations. I bought a case of ten 3.5-inch floppies and headed to the local chess club. They had a 486 that people were supposed to use to study and play chess, but it also moonlighted as a software stash for club members under 25. That afternoon I spent twenty minutes swapping floppies in and out of the computer, labeling them as Mortal Kombat II RAR Volume 1/8 , etc. That same procedure would have to be reenacted backwards at home, once a beige box graced my desk with its presence. Was it worth it? Yes. Did I play the game much? I played the hell out of it that Xmas. Why are you telling me this stuff? Because I want to talk about... Compromise Look. In order to play that thing, I had to: Walk twenty minutes to the chess club Pester someone to get my turn at the computer Wait twenty more minutes in front of it Walk back home Spend twenty extra minutes unRARing the stuff After all that, I would have played the game even if it sucked! Maybe it sucked and I didn't notice! I invested some of my time in getting it running so, had it failed to meet my expectations, I would have been left with these two options: Deciding that I was stupid for wasting a perfectly good afternoon Tricking myself into thinking that the game was good Back then, I didn't think of myself as a stupid person, so I would have gone for the second one. Of course, the game was actually good, so it's a moot point. But anyways, what's the moral of the story? Wasting the time of players increases the subjective appeal of games Which is kind of tragic, given today's sorry state of software distribution. People don't go to game stores anymore. They don't ask their friends for games, either. They just wait for the Steam sale, whip out a credit card and pay a visit to the fridge while their game downloads. Where's the compromise in that? We can do better. Up for some unsolicited advice? Thought so. If you're a game developer and want your stuff to be noticed, forget greenlight . What you need is 20th century game distribution and you know it. The days of tapes and floppies may be long gone, but when everything seems lost, you can always count on good old... D.R.M. Here's my proposal: Upload your game somewhere and force your first users to contact you to get an activation key. ( wasted time + social interaction = ugly experience ). Since you don't want to spend all day handing keys over, unload that burden on your players. Make it so that every unlocked copy of your game is capable of generating valid activation keys ( oh this game has to be reaally good if im answering peoples emails just because i wrote in a forum that i was playing it ). ... Profit! That's the gist of the inDRM copy control scheme, my contribution to this year's SIGBOVIK conference . If you want to know more, check the article and browse the associated GitHub repository . List of games using inDRM None so far, but they're coming.","tags":"tools","loc":"https://blog.debiatan.net/inDRM.html","title":"inDRM: Copy control with a personal touch"},{"text":"You may be aware that Barcelona holds a couple dozen Mobile World Congresses a year. However, you probably ignore that there are other technological meetings in Barcelona that far surpass the MWC by any metric you can think of. The QIDV ( Quedadas informales de desarrollo de videojuegos , Meetups about Game Development) are the most prominent example. For the tenth edition of these gatherings, I decided to give a talk to raise awareness of Casey Muratori's Handmade Hero project. I tried to summarize the highlights of the first five weeks in just fifteen minutes, explaining mainly the architectural decisions that support the live code editing capabilities of his platform layer. If you couldn't come but understand Spanish, I invite you to take a look at the recording of the session: Here's just the fun part (the demo) at the end: And here's the whole thing: If you don't feel satisfied by my bare bones explanation of the technical details, please resort to this nicely written post about the subject . If that still doesn't do the trick, you can always watch the original Handmade Hero video . Enjoy!","tags":"tools","loc":"https://blog.debiatan.net/five-weeks-of-handmade-hero.html","title":"Five weeks of Handmade Hero"},{"text":"This weekend I took part in the seventh edition of the Global Game Jam . The goal of the event is to create a game related in some way to a given theme in 48 hours. This year's theme was What do we do now? . Instead of flying solo, as I did last year, I joined two friends: Javi and Esteban. It payed off big time, not only because jamming alone doesn't make any sense (I can code by myself any weekend I so desire -- which is most of them), but also because I jammed in good company and we fucking won the local Barcelona section of the jam . Gorilla-bears chasing dinner. If you want a detailed account on how it went or some technical tips to play the game, I refer you to Javi's write-up . Other than that, here's the profile of the game at the GGJ web page and a link to the game . Enjoy! (UPDATE) Here's the presentation of the game Javi gave at the end of the jam:","tags":"jams","loc":"https://blog.debiatan.net/acampa-como-puedas.html","title":"Acampa como puedas"},{"text":"It seems that building an oscilloscope on top of an Arduino board is some sort of rite of passage. Do a duckduckgo search and you will see that all the good names for this kind of project are already taken, so I have decided to name mine just oscilloscope . In my defense, I'll say that I have written mine because I needed the most basic of oscilloscopes and it's just easier to build one from scratch than to adapt some already existing code. I've written my oscilloscope code it in order to inspect a single-channel periodic signal with a frequency close to 250 Hz. My first trivial attempt at the task already recorded the signal at 5 kHz and transmitted it over USB without the need to buffer data in the RAM of the microcontroller, so I haven't bothered speeding it up. The main bottleneck in my case is the serial transmission. Trying to collect more than 5800 samples per second will likely result in the loss of some of them. I've written some extra code that checks for missing samples, but it never detects problems at 5 kHz and, frankly, I'm OK with twenty samples per cycle. All in all, putting together the C firmware and the Python client, the project takes less than 130 lines. The program that checks for periodicity, finds the frequency and aligns the cycles to display them adds 90 extra lines. The output of this program looks like this: Visualization of several cycles of a PWM signal at 250 Hz after going through a simple RC circuit. Here's the link to the github repository .","tags":"tools","loc":"https://blog.debiatan.net/oscilloscope.html","title":"Oscilloscope"},{"text":"Just to keep the blog rolling, I'm posting this ten-second clip of Guybrush Threepwood coming into existence from some sort of primordial soup of pixels. On the left, you can see the distortion field applied to the original image to deform it. It consists of a field of vectors, each of them centered on a pixel of the image, following a 2D Ornstein-Uhlenbeck process . They are convolved with a Gaussian kernel that grows as the video steps forward.","tags":"thingies","loc":"https://blog.debiatan.net/guybrush.html","title":"Distortion Vector Field"},{"text":"UTBP is a new subparadigm of Declarative Programming, in which code is generated from a description of its intended behavior, specified through unit tests. This work was presented at SIGBOVIK 2014 and received the Most Frighteningly Like Real Research Award. For an in-depth tour of UTBP, you can check the article and browse the associated GitHub repository . If you prefer a light introduction, you can choose between two versions of the same video. This one is dubbed: This one is subbed:","tags":"tools","loc":"https://blog.debiatan.net/utbp.html","title":"Unit-Test-Based Programming"},{"text":"This weekend I participated in the sixth edition of the Global Game Jam . The goal of the event was to create a game related in some way to a given theme in 48 hours. This year's theme was We don't see things as they are, we see them as we are . I decided to go for a multiplayer Gradius clone in which collisions with enemies remap your controls. I developed it using CodeSkulptor , which is basically a Python interpreter running on top of Javascript. Needless to say, it's no speed demon. See for yourself: If you want to give it a try, I have two suggestions to make: Find someone to play against (otherwise is going to look as sad as my single player game above). Run it on Chrome. Here's the profile of the game at the GGJ webpage and a link to the game . Enjoy! Update : Looks like my game placed third on the local vote we held after the Jam! Hooray!","tags":"jams","loc":"https://blog.debiatan.net/gradius-meets-twister.html","title":"Gradius meets Twister"},{"text":"Every once in a while, I need to step outside the command line. Sometimes I'm even forced to interact with deaf graphical programs, those that do not listen to standard input or a meager HTTP port. In those desperate times, were it not for tools such as XAUT or xdotool , I would have to type and click outside of VIM , like cavemen probably did. Those two little programs are enough to make me happy when confronted with an X11 server. However, my computer, of a more whimsical nature, is reluctant to execute binaries other than a Python interpreter (like any other well-meaning general-purpose device assembled during the 21st century, really). That is why I have decided to write the simplest Python library I could think of that is able to: Find out the position of the mouse pointer Move the mouse pointer around the screen Press and release mouse buttons Press and release keys in the keyboard Capture the screen The xrobot library is lean, simple and Python[23]-compliant. It is just a wrapper around functions defined inside python-xlib . Since Xlib screen capture is painfully slow, the python-gtk bindings are used instead, if present. I have decided to return images as numpy arrays for my convenience; if you find that dependency unbearable, you can root it out easily from the code. Here's me, at five hundred clicks/second. I leave you with a link to the xrobot github repository and some sample code: import xrobot xr = xrobot . XRobot () xr . move ( 10 , 10 ) robot = XRobot () x , y = robot . mouse_pos () print ( 'Current mouse position: x =' , x , 'y =' , y ) robot . move ( 10 , 10 ) robot . click ( 1 ) robot . key ( 'a' ) # Press and release 'a' robot . key_down ( 'comma' ) # Press ',' robot . key_up ( 'comma' ) # Release ',' width , height = robot . screen_resolution () print ( 'Screen width:' , width , 'Screen height:' , height ) img = robot . capture_screen () import pylab as pl pl . imshow ( img ) pl . show ()","tags":"tools","loc":"https://blog.debiatan.net/xrobot.html","title":"xrobot"}]}